Footer:
for when page height < 100vh
set pos: abs, top 100vh - (height of footer)
when page height > 100vh
@media screen and ( min-height: 100vh ){
    pos: static
}

Make text with a gradient color (could also have an image behind it):
background-image: linear-gradient(135deg, yellow, violet);
background-clip: text;
color: transparent;
padding: .5em;
box-decoration-break: clone;

CSS Variables:
Has good support now!
:root {
  --first-color: #488cff;
  --second-color: #ffff8c;
}
#firstParagraph {
  background-color: var(--first-color);
  color: var(--second-color);
}
custom properties are tied to a selector. The selector will cascaded like normal
but any place you use var() also has a rule that matches which includes the def

// works
div { --color: red; }
div.alert { background-color: var(--color); }

// Won't work!
div { --color: red; }
p.alert { background-color: var(--color); }

Realistically it is probably easiest to just define all vars in :root/html (they are the same thing in html docs)
Css variables are interpreted in the browser at runtime, so you can change the value of a custom property inside a media query, with a pseudo selector such as hover, or even with JavaScript.

You can use custom variables to simplify media queries
* instead of defining different rules, create 1 rule and then use variables. Use media queries to set the right variables

To update a css var with JS
const elem = document.documentElement;
elem.style.setProperty('--USER-THEME-COLOR', 'tomato');

:matches() - can match multiple elems - very convenient
instead of: nav .nav-link, footer .nav-link, header .nav-link {}
use: :matches(nav, footer, header) .nav-link {}

Every element in a HTML document can set it’s own individual language by using the lang attribute.
<div lang=”en”>The language of this element is set to English.</div>
<div lang=”el”>Η γλώσσα αυτού του στοιχείου έχει οριστεί στα ελληνικά.</div>
<div lang=”is”>Tungumál þessa þáttar er sett á íslensku.</div>
The <div> elements can be matched using the :lang() selector:
:lang(en) { color: red; }

New Measurement Units!
lh is equal to the current line height
rlh is the equivalent of what rem is to em: the line height on the root element

vi is 1% of the size of the viewport in the inline direction;
vb is 1% of the size of the viewport in the block direction.
^ Useful for vertical languages like Japanese - you could use vw and vh, but if you switched the localization to Japanese, you would have to switch the vw and vh measurements
vi and vb give you a measurement system realative to the positioning of the text, so you it would work with both Japanese and English
Angular measurements:
deg
turn - equal to 360deg
grad - gradians (not useful?)
rad - radians

Aspect ratio
@media screen and (min-aspect-ratio: 16/10) {...}

vmin and vmax - represents the bigger/smaller side of the viewport instead of the height and width.


BEM (Blocks Elements Modifier):
--> how do you reuse styles in different parts of the app??
use only class selectors:
** tags and attributes are used by the html, may change breaking css
** classes shouldnt need to change, if they do it is a simple find+replace
** classes are to css what id's are to db's: don't mix html business logic with style logic
* You also shouldn't use * universal selector, or anything but simple classes - this will make your css easy to refactor
Nested selectors increase code coupling and make it difficult to reuse the code.
Dont use combined selectors: class="button button_theme_islands":
** Combined selectors are more specific than single selectors, which makes it more difficult to redefine blocks.
** Also the combined selectors may conflict with each other
** likewise you shouldn't combine button and class: button.active (button style and active style may conflict)

A given element should only have one rule styling it. This reduces conflicts, and makes it easy to refactory css (a simple search will show you all the places the style is used)
Could you do this with Sass to define %rules and then @extend them in your sass?
Block - a logical parent for html children (ex a form)
** All parts of the form (the form block) that don’t make sense on their own are considered its elements.
In BEM, to underscores are used as a seperator
classes are named block__element (ex form__submit)

A modifier defines the look, state and behavior of a block or an element. Adding modifiers is optional. you can use any number of modifiers
a block or an element can’t be assigned different values of the same modifier.
ex form_type_original
A modifier contains only additional styles that change the original block implementation in some way. This allows you to set the appearance of a universal block only once, and add only those features that differ from the original block code into the modifier styles.
modifiers should all be included on the same element
<form class="form form_type_original"></form>
modifiers should only add properties, not override the original properties

BEM is now supported in SCSS:
.note {
  color: #ffffff;
  &__content {
    background: white;
  }
}

then you can use class="note__content" in your html. So you get SCSS nesting and BEM
