<?doctype html>

<html>

<head>

<style>
  h1 {text-align: center; margin: 2em;}
  code, pre {
    display: block; background-color: #f1f0f0;
    width: 66%; margin: 1.5rem auto; padding: 2em 3em;
    border: 1px solid darkgray; box-shadow: 0 0 5px #ccc inset;
  }

</style>

</head>

<body>

<h1>The 8 Different Values of 'this' in JS</h1>

<pre>
// 1. Global Namespace - outside of a funnction or object, this = window or the global context
test1 = "hello";
console.log(this.test1);
</pre>

<pre>
// 2. Eval - this comes from the execution context, or window
function This1() {
  this.hello = "world";
  //this evaluated at runtime
  this.evalHello = function() {return eval("this.hello");}
}
new This1().evalHello(); //world
</pre>

<pre>
//3. Bind, Call and Apply - this is passed as a parameter
var myContext = {greet: 'hey'};
function sayHey(person) {
  return this.greet + " " + person;
}
sayHey.call(myContext, 'you');
sayHey.apply(myContext, ['there']);
sayHey.bind(myContext)();
// only difference between call and apply is that apply takes args in a single array
// bind returns a function (does not execute the target function)
</pre>

<pre>
//4. Inside a normal function (including anonymous functions)
//    It's complicated - 'this' is bound at runtime, depending on the context it's called from
//    Best to always avoid using this pattern!
test4Str = "hello!";
function test4() {
  return this.test4Str;
}
test4();

//The this binding is done at runtime!
var test4b = {
  hello: 'world',
  sayHi: function() {
    console.log(this.hello);
  }
}
test4b.sayHi(); //world
var test4c = test4b.sayHi
test4c(); //undefined!!!

var test4d = function() {
  console.log(this.hello);
}
test4b['myTest4d'] = test4d;
test4d(); //undefined
test4b.myTest4d(); //world
</pre>

<pre>
//5. Inside a function invoked with 'new' - this refers to the object instance, just like Java
function Test5() {
  //constructor
  this.hello = "world";
  this.sayHello = function() {return "hello " + this.hello}
}
//Added method - on prototype to avoid a new definition for each instance
Test5.prototype.sayGoodbye = function() {return "goodbye " + this.hello;}
//Object instance
t5 = new Test5();
t5.sayHello();
t5.sayGoodbye();
</pre>

<pre>
//6. Closure - closures inside objects lose their reference to the object's this - it is bound at execution time and
//    changes - to reference the object's this use the var that = this trick
function Test6() {
  this.greeting = "hi";
  var that = this; //private var, inaccessible from outside obj.
  this.badClosure = function() {
    return function() {
      return "greeting: " + this.greeting;
    }
  }
  this.goodClosure = function() {
    return function() {
      return "greeting2: " + that.greeting;
    }
  }
}
t6 = new Test6();
t6.badClosure()();    //'greeting: undefined'
t6.goodClosure()();   //'greeting2: hi'
t6.that;              //undefined
</pre>

<pre>
//7. Fat arrow function closures - retain their reference to this
function Test7() {
  this.greeting = "hi";
  this.badClosure = function() {
    return () => {
      return "greeting: " + this.greeting;
    }
  }
}
t7 = new Test7();
t7.badClosure()();
</pre>

<pre>
//8. Event Listeners - this resolves to the dom node that recieved the event
document.addEventListener("click", function() {
  this //resolves to document
})
document.querySelector("input[type=submit]").addEventListener("click", function() {
  this //resolves to the submit button
})
</pre>

</body>
</html>