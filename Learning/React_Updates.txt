React Updates

v16.0
* You can now return a list of elements in render()!!
render() {
  return [
    <div/>
    <div/>
  ];
}

In 16.2 you will be able to return strings!!
render() {
  return 'my string';
}

The render() function should be pure, meaning that it does not modify component state
User lifecycle methods to update state

Error Boundaries:
By default, if an error is thrown inside a component’s render or lifecycle methods, the whole component tree is unmounted from the root.
Error boundaries are special components that capture errors inside their subtree and display a fallback UI in its place. Think of error boundaries like try-catch statements, but for React components.
To use these, in your component define lifecycle method: componentDidCatch(error, info):
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  componentDidCatch(error, info) {
    // Display fallback UI
    this.setState({ hasError: true });
    // You can also log the error to an error reporting service
    logErrorToMyService(error, info);
  }
  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
You can wrap subcomponents in a special error handling component:
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>

Portals:
Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
render() {
  // React does *not* create a new div. It renders the children into `domNode`.
  // `domNode` is any valid DOM node, regardless of its location in the DOM.
  return ReactDOM.createPortal(
    this.props.children,
    domNode,
  );
}

componentWillMount is going away!


Context!----------------------------
* will be totally different in updated versions of react. Replace redux?
* convenient place to store 'global' data - anything which isn't passed top down

// Create a context for the current theme (with "light" as the default).
const ThemeContext = React.createContext('light');

// Use a Provider to pass the current theme to the tree below.
// Any component can read it, no matter how deep it is.
// In this example, we're passing "dark" as the current value.
<ThemeContext.Provider value="dark">
  <Toolbar />
</ThemeContext.Provider>

// Use a Consumer to read the current theme context.
// React will find the closest theme Provider above and use its value.
// In this example, the current theme is "dark".
return (
  <ThemeContext.Consumer>
    {theme => <Button {...props} theme={theme} />}
  </ThemeContext.Consumer>

* The context has both providers and consumers. Can only save 1 value.
const {Provider, Consumer} = React.createContext(defaultValue);

// A React component that allows Consumers to subscribe to context changes.
<Provider value={/* some value */}>

// A React component that subscribes to context changes. Requires a function as a child. The function receives the current context value and returns a React node.
// The value argument passed to the function will be equal to the value prop of the closest Provider for this context above in the tree.
// If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext().
<Consumer>
  {value => /* render something based on the context value */}
</Consumer>

All Consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes
The propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, so the Consumer is updated even when an ancestor component bails out of the update.

You will likely have to define ThemeContext in one file, and then import it in the other files

To update the context:
In the provider set the state of a component to the context value
<ThemeContext.Provider value={this.state}>
There can be a method (ex `toggleTheme`) which will change the state.
This can also be included in the context (first included it in the state)
Then this context can be used in subcomponents. The toggleTheme method can be pulled from the context, and called
<ThemeContext.Consumer>
  {({theme, toggleTheme}) => (
    <button
      onClick={toggleTheme}
      style={{backgroundColor: theme.background}}>
      Toggle Theme
    </button>
  )}
</ThemeContext.Consumer>

You can have multiple contexts. Each one requires its own Provider and Consumer

To use context values in lifecycle methods, or to simplify, pass the context values to props:
class Button extends React.Component {
  render() {
    const {theme, children} = this.props;
  }
}
export default props => (
  <ThemeContext.Consumer>
    {theme => <Button {...props} theme={theme} />}  // Theme is just a normal prop here
  </ThemeContext.Consumer>
);

You could also create a common HOC to add this context property to props:
export function withTheme(Component) {
  return function ThemedComponent(props) {
    return (
      <ThemeContext.Consumer>
        {theme => <Component {...props} theme={theme} />}
      </ThemeContext.Consumer>
    );
  };
}

Then in the child component definition:
export withTheme(Button);

Anytime a new object is passed to the Provider, the Consumers will rerender
With the below, any time the component is rerendered the consumers will be rerendered, because {something: 'something'} is a new object.
<Provider value={{something: 'something'}}>
To fix this, move {something: 'something'} out of render(). The obvious place to put it would be in the components state. Then it will persist across render() calls
