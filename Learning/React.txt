create-react-app
* no support for sass/less!
** would require using eject()

* webpack - importing an image tells webpack to include the image in the prod bundle
** webpack moves all images into the build path - access them in the html with
import logo from './logo.png';
<img src={logo} alt="Logo" />;
or
background-image: url(./logo.png);
* there is also the public directory, but you should import images instead
* files in /public are not processed by webpack - they are copied into build dir untouched

Use https://react-bootstrap.github.io for bootstrap
** also install bootstrap and import css to get the css grid

* CRA has a built in test runner!!
** works similar to karma
** npm test goes into watch mode
By default, when you run `npm test`, Jest will only run the tests related to files changed since the last commit.
You can also press `a` in the watch mode to force Jest to run all tests.

Jest is just like Jasmine!!!!!!!!!!!!
* read up on snapshots!

React storybook to create style guides - integrates nicely with CRA

Handling form data:----------------------
Method one: set onChange={} on every input - each handler will update the component's state
Method two: use ref to get save the dom element to the component - this way you can get the form field value on submit, or whenever you need it, instead of having to setState and adding onChange to every element
onSubmit() {
  alert(this.myInput.value);
}
render() {
  //this.myInput is set when the component is mounted
  return <input ref={(input) => this.myInput = input}
}
* this way allows you to skip the handlers and my be easier to integrate preexisting code, but otherwise sucks
* you can set defaultValue property on input components

React supports a key attribute for elements in lists. When children have keys, React uses the key to match children in the original tree with children rendered in the subsequent tree - so it can take the original elements and put them in the new list, without having to rerender every element in the list
* this means your keys have to be unique, and must stay consistent between renderings of the list - DONT USE INDEX! - it will not uniquely identify an element
The key only has to be unique among its siblings, not globally unique.
As a last resort, you can pass item's index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.

Context:------------------------------
* new/experimental feature of react - Don't use it yet
* works like a global variable
* allows parent components to set a property on the context
* any descendent element in the tree will be able to get that property from the context
* the property doesn't have to be explicitly passed in props
//parent prop
getChildContext() {
    return {color: "purple"};
  }
// child component, or child of a child, etc
<button style={{background: this.context.color}}>
* for context, you have to set the PropTypes
* lifecycle methods will also be passed the context
In order to update data in the context, trigger a local state update with this.setState. This will trigger a new context and changes will be received by the children.
-- this doesn't work well!! intermediate children may not update if parent component changes state, meaning children one level down will not be rerendered and will not see the new context

Higher-Order Components
HOCs are not part of the React API, per se. They are a pattern that emerges from React's compositional nature.
HOCs are a function that takes a component and returns a new component.
Whereas a component transforms props into UI, a higher-order component transforms a component into another component.
* connect() in react-redux is a HOC
HOCs are functions that take a component, and maybe some other args, and return a component. the new component may have some methods added, and will return the wrapped original component
* HOCs wrap, not inherit
* you can chain calls to HOC's
* don't mutate the original component - chained HOCs may overwrite each other
* ref's aren't passed through HOCs



Performance:--------------------
* react has two distributions - dev build and prod build
* the dev build includes lots warnings to catch bad practices - it is bigger and slower than the prod version
* To see which you are using, install the react developer tools plugin
** if the plugin has a black background, it is using the prod version
** if the plugin has a red background, the site's using the dev version



React Routes--------------
At its heart, React Router is a component.

render((
  <Router history={hashHistory}>
    <Route path="/" component={App}/>
    {/* add the routes here */}
    <Route path="/repos" component={Repos}/>
    <Route path="/about" component={About}/>
  </Router>
), document.getElementById('app'))

Perhaps the most used component in your app is Link. It's almost identical to the <a/> tag you're used to except that it's aware of the Router it was rendered in.

import { Link } from 'react-router'
<Link to="/about">About</Link>

 every route can be developed (even rendered!) as an independent application. Your route configuration stitches all these apps together however you'd like

 You can also nest routes
 <Route path="/" component={App}>
  {/* make them children of `App` */}
  <Route path="/repos" component={Repos}/>
  <Route path="/about" component={About}/>
</Route>

<Route path="/repos/:userName/:repoName" component={Repo}/>
In Repo:
{this.props.params.repoName}

Set default with IndexRoute
Notice how the IndexRoute has no path. It becomes this.props.children of the parent when no other child of the parent matches
